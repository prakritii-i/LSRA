{"version":3,"sources":["../src/errors/NotFound.ts","../src/errors/RequestError.ts","../src/utils.ts","../src/client.ts"],"sourcesContent":["export class NotFoundError extends Error {\n  constructor() {\n    super(\"Track was not found\");\n  }\n}\nexport class NoResultError extends Error {\n  constructor() {\n    super(\"No result was found\");\n  }\n}\n","export class RequestError extends Error {\n  constructor(error?: string) {\n    super(\"Request error \" + error);\n  }\n}\n\nexport class KeyError extends Error {\n  constructor(error?: string) {\n    super(\"The key has not been configured.\");\n  }\n}\n","import { LyricLine, ParsedLyrics } from \"./types/Utils\";\n\n/**\n * Parses song lyrics into a structured format by removing metadata tags and separating lines.\n *\n * Example Input:\n * ```\n * [00:27.93] Listen to the wind blow\n * [00:30.88] Watch the sun rise\n * ```\n *\n * Example Output:\n * {\n *   synced: [{ text: \"Listen to the wind blow\", startTime: 27930 }, { text: \"Watch the sun rise\", startTime: 30880 }],\n *   unsynced: []\n * }\n *\n * @param lyrics - The raw lyrics string with optional tags and timestamps\n * @returns A ParsedLyrics object containing structured lyric data\n */\nfunction parseLocalLyrics(lyrics: string): ParsedLyrics {\n  // Preprocess lyrics by removing [tags] (e.g., [artist:Name]) and trimming extra whitespace\n  const lines = lyrics\n    .replace(/\\[[a-zA-Z]+:.+\\]/g, \"\") // Removes metadata tags like [artist:Name]\n    .trim()\n    .split(\"\\n\"); // Splits the lyrics into an array of lines\n\n  // Regular expressions for matching synced and karaoke timestamps\n  const syncedTimestamp = /\\[([0-9:.]+)\\]/; // Matches [00:12.34]\n\n  const unsynced: LyricLine[] = []; // Array to store unsynchronized lyrics\n  const synced: LyricLine[] = []; // Array to store synchronized lyrics\n\n  // Process each line to extract lyrics and timing information\n  lines.forEach((line) => {\n    // Match synchronized lyrics\n    const syncMatch = line.match(syncedTimestamp);\n    if (syncMatch) {\n      const startTime = parseTime(syncMatch[1]);\n      const text = line.replace(syncedTimestamp, \"\").trim();\n      if (text) {\n        synced.push({ text, startTime });\n      }\n    }\n    // Add to unsynchronized lyrics if no timestamps are found\n    else {\n      const text = line.trim();\n      if (text) {\n        unsynced.push({ text });\n      }\n    }\n  });\n\n  return {\n    synced: synced.length > 0 ? synced : null,\n    unsynced,\n  };\n}\n\n/**\n * Converts a timestamp string in the format \"mm:ss\" or \"mm:ss.SSS\" to a number in seconds.\n *\n * @param time - The timestamp string to parse\n * @returns The time in seconds as a number\n */\nfunction parseTime(time: string): number {\n  const [minutes, seconds] = time.split(\":\").map(Number);\n  return minutes * 60 + seconds;\n}\n\nexport { parseLocalLyrics, parseTime };\n","import { KeyError, NoResultError, NotFoundError, RequestError } from \"./errors\";\nimport { ChallengeResponse, ClientOptions } from \"./types/Client\";\nimport {\n  FindLyricsResponse,\n  PublishLyrics,\n  Query,\n  Search,\n} from \"./types/Lyrics\";\nimport { LyricLine } from \"./types/Utils\";\nimport { parseLocalLyrics } from \"./utils\";\n\nexport class Client {\n  private _url: string = \"https://lrclib.net/api\";\n  private _key: string | undefined;\n  /**\n   * Creates a request client to api\n   *\n   * Example Usage;\n   * ```typescript\n   * const client = new Client();\n   *\n   * client.findLyrics({ track_name: \"The Chain\", artist_name: \"Fleetwood Mac\" }).then(console.log);\n   * ```\n   *\n   * @notigorwastaken: I'm still working on it.\n   *\n   * @param options - An optional object containing Client Options\n   *  - `url`: The base URL, e.g. you can set up a custom url that uses another lrclib.net instance\n   *  - `key`: The token used to publish lyrics to the api. [click here for more info](https://lrclib.net/docs)\n   */\n  constructor(options?: ClientOptions) {\n    this._url = options?.url || this._url;\n    this._key = options?.key;\n  }\n  private async request(\n    path: string,\n    options?: RequestInit,\n  ): Promise<Response> {\n    return await fetch(this._url + path, options);\n  }\n  private async post(\n    path: string,\n    body: any,\n    options?: RequestInit,\n  ): Promise<string> {\n    if (!this._key) throw new KeyError();\n    const response = await fetch(this._url + path, {\n      ...options,\n      headers: {\n        \"X-Publish-Token\": this._key,\n      },\n      body: JSON.stringify(body),\n      method: \"post\",\n    });\n    if (response.status !== 201) throw await response.json();\n    return await response.text();\n  }\n  private async postAlt(\n    path: string,\n    headers?: any,\n    body?: any,\n    options?: RequestInit,\n  ): Promise<Response> {\n    return await fetch(this._url + path, {\n      method: \"post\",\n      headers,\n      body: body,\n      ...options,\n    });\n  }\n  /**\n   * Sends a request to the lyrics search API at https://lrclib.net/api/search.\n   *\n   * Example Usage:\n   * ```typescript\n   * const search = await searchLyrics({ query: \"The Chain\" });\n   * ```\n   *\n   * @param info - An object containing search parameters:\n   *  - `query`: The search term (conditional | e.g., song title or lyrics fragment).\n   *  - `track_name`: The name of the track (conditional).\n   *  - `artist_name`: The artist's name (optional).\n   *  - `duration`: The song duration in milliseconds (optional).\n   *\n   * @returns A promise that resolves to an array of {@link FindLyricsResponse | FindLyricsResponse[]}.\n   */\n  public async searchLyrics(\n    info: Search,\n    options?: RequestInit,\n  ): Promise<FindLyricsResponse[]> {\n    const baseURL = \"/search\";\n    const params = {\n      q: info.query || \"\",\n      track_name: info.track_name || \"\",\n      artist_name: info.artist_name || \"\",\n      duration: info.duration ? info.duration / 1000 : \"\",\n    };\n    const finalURL = `${baseURL}?${Object.entries(params)\n      .filter(([_, value]) => value !== undefined && value !== \"\")\n      .map(([key, value]) => `${key}=${encodeURIComponent(value as string)}`)\n      .join(\"&\")}`;\n    const response = await this.request(finalURL, options);\n\n    if (!response.ok) {\n      throw new RequestError();\n    }\n    const body = await response.json();\n\n    if (!body) {\n      throw new NoResultError();\n    }\n\n    return body;\n  }\n\n  /**\n   * Finds lyrics for a given track using the API at https://lrclib.net/api/get.\n   *\n   * Example Usage:\n   * ```typescript\n   * const lyrics = await findLyrics({ track_name: \"The Chain\", artist_name: \"Fleetwood Mac\" });\n   * ```\n   *\n   * @param info - An object containing query parameters:\n   *  - `id`: The unique identifier of the track (conditional).\n   *  - `track_name`: The name of the track (conditional).\n   *  - `artist_name`: The artist's name (conditional).\n   *  - `album_name`: The album's name (optional).\n   *  - `duration`: The song duration in milliseconds (optional).\n   *\n   * @returns A promise that resolves to a {@link FindLyricsResponse | FindLyricsResponse} object containing the track's lyrics.\n   * @throws Will throw an error if the request fails or the track is not found.\n   */\n  public async findLyrics(\n    info: Query,\n    options?: RequestInit,\n  ): Promise<FindLyricsResponse> {\n    const parseID = info.id ? `/${info.id}` : \"?\";\n    const baseURL = \"/get\" + parseID;\n    const durr = info?.duration ? info.duration / 1000 : undefined;\n    const params = {\n      track_name: info.track_name || \"\",\n      artist_name: info.artist_name || \"\",\n      album_name: info.album_name || \"\",\n      duration: durr || \"\",\n    };\n\n    const finalURL = `${baseURL}${Object.entries(params)\n      .filter(([_, value]) => value !== undefined && value !== \"\")\n      .map(([key, value]) => `${key}=${encodeURIComponent(value as string)}`)\n      .join(\"&\")}`;\n\n    const response = await this.request(finalURL, options);\n    if (!response.ok && response.status === 404) {\n      throw new NotFoundError();\n    } else if (!response.ok && response.status !== 200) {\n      throw new RequestError(response.statusText);\n    }\n\n    const body = await response.json();\n\n    return body;\n  }\n\n  /**\n   * Retrieves unsynchronized (plain) lyrics for a given track.\n   *\n   * Example Usage:\n   * ```typescript\n   * const unsyncedLyrics = await getUnsynced({ track_name: \"The Chain\", artist_name: \"Fleetwood Mac\" });\n   * ```\n   *\n   * @param info - An object containing query parameters:\n   *  - `id`: The unique identifier of the track (conditional).\n   *  - `track_name`: The name of the track (conditional).\n   *  - `artist_name`: The artist's name (conditional).\n   *  - `album_name`: The album's name (optional).\n   *  - `duration`: The song duration in milliseconds (optional).\n   *\n   * @returns A promise that resolves to an array of {@link LyricLine | LyricLine[]} objects\n   *          containing unsynchronized lyrics or `null` if no lyrics are found.\n   */\n  public async getUnsynced(info: Query): Promise<LyricLine[] | null> {\n    try {\n      const body = await this.findLyrics(info);\n      if (\"error\" in body) return null;\n\n      const unsyncedLyrics = body?.plainLyrics;\n      const isInstrumental = body.instrumental;\n      if (isInstrumental) return [{ text: \"[Instrumental]\" }];\n\n      if (!unsyncedLyrics) return null;\n\n      return parseLocalLyrics(unsyncedLyrics).unsynced;\n    } catch (e) {\n      console.error(e);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves synchronized (timed) lyrics for a given track.\n   *\n   * Example Usage:\n   * ```typescript\n   * const syncedLyrics = await getSynced({ track_name: \"The Chain\", artist_name: \"Fleetwood Mac\" });\n   * ```\n   *\n   * @param info - An object containing query parameters:\n   *  - `id`: The unique identifier of the track (conditional).\n   *  - `track_name`: The name of the track (conditional).\n   *  - `artist_name`: The artist's name (conditional).\n   *  - `album_name`: The album's name (optional).\n   *  - `duration`: The song duration in milliseconds (optional).\n   *\n   * @returns A promise that resolves to an array of {@link LyricLine | LyricLine[]} objects\n   *          containing synchronized lyrics or `null` if no lyrics are found.\n   */\n  public async getSynced(info: Query): Promise<LyricLine[] | null> {\n    try {\n      const body = await this.findLyrics(info);\n      const syncedLyrics = body?.syncedLyrics;\n      const isInstrumental = body.instrumental;\n      if (isInstrumental) return [{ text: \"[Instrumental]\" }];\n\n      if (!syncedLyrics) return null;\n\n      return parseLocalLyrics(syncedLyrics).synced;\n    } catch (e) {\n      console.error(e);\n      return null;\n    }\n  }\n  public async requestChallenge(): Promise<ChallengeResponse | null> {\n    try {\n      const challenge = await this.postAlt(\"/request-challenge\");\n      if (!challenge.ok) throw new RequestError(challenge.statusText);\n      const response = await challenge.json();\n      if (!response.prefix || !response.target) return null;\n      return {\n        prefix: response.prefix,\n        target: response.target,\n      };\n    } catch (e: any) {\n      throw new Error(e?.message ?? \"Unknown Error\");\n    }\n  }\n  /**\n   * This is an experimental function / API.\n   \n  public async publishLyrics(info: PublishLyrics) {\n    try {\n      const challenge = await this.requestChallenge();\n      const response = await this.postAlt(\n        \"/publish\",\n        {\n          \"X-Publish-Token\":\n            challenge?.prefix +\n            \":\" +\n            solveChallenge(\n              challenge?.prefix as string,\n              challenge?.target as string,\n            ),\n          \"content-type\": \"application/json\",\n          Accept: \"application/json\",\n        },\n        {\n          track_name: info.trackName,\n          artist_name: info.artistName,\n          album_name: info.albumName,\n          duration: info.duration,\n          plain_lyrics: info.plainLyrics,\n          synced_lyrics: \"\",\n        },\n      );\n      return response;\n    } catch (e: any) {\n      throw new Error(e?.message ?? \"Unknown Error\");\n    }\n  }*/\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAO,MAAM,gBAAN,cAA4B,MAAM;AAAA,IACvC,cAAc;AACZ,YAAM,qBAAqB;AAAA,IAC7B;AAAA,EACF;AACO,MAAM,gBAAN,cAA4B,MAAM;AAAA,IACvC,cAAc;AACZ,YAAM,qBAAqB;AAAA,IAC7B;AAAA,EACF;;;ACTO,MAAM,eAAN,cAA2B,MAAM;AAAA,IACtC,YAAY,OAAgB;AAC1B,YAAM,mBAAmB,KAAK;AAAA,IAChC;AAAA,EACF;AAEO,MAAM,WAAN,cAAuB,MAAM;AAAA,IAClC,YAAY,OAAgB;AAC1B,YAAM,kCAAkC;AAAA,IAC1C;AAAA,EACF;;;ACUA,WAAS,iBAAiB,QAA8B;AAEtD,UAAM,QAAQ,OACX,QAAQ,qBAAqB,EAAE,EAC/B,KAAK,EACL,MAAM,IAAI;AAGb,UAAM,kBAAkB;AAExB,UAAM,WAAwB,CAAC;AAC/B,UAAM,SAAsB,CAAC;AAG7B,UAAM,QAAQ,CAAC,SAAS;AAEtB,YAAM,YAAY,KAAK,MAAM,eAAe;AAC5C,UAAI,WAAW;AACb,cAAM,YAAY,UAAU,UAAU,CAAC,CAAC;AACxC,cAAM,OAAO,KAAK,QAAQ,iBAAiB,EAAE,EAAE,KAAK;AACpD,YAAI,MAAM;AACR,iBAAO,KAAK,EAAE,MAAM,UAAU,CAAC;AAAA,QACjC;AAAA,MACF,OAEK;AACH,cAAM,OAAO,KAAK,KAAK;AACvB,YAAI,MAAM;AACR,mBAAS,KAAK,EAAE,KAAK,CAAC;AAAA,QACxB;AAAA,MACF;AAAA,IACF,CAAC;AAED,WAAO;AAAA,MACL,QAAQ,OAAO,SAAS,IAAI,SAAS;AAAA,MACrC;AAAA,IACF;AAAA,EACF;AAQA,WAAS,UAAU,MAAsB;AACvC,UAAM,CAAC,SAAS,OAAO,IAAI,KAAK,MAAM,GAAG,EAAE,IAAI,MAAM;AACrD,WAAO,UAAU,KAAK;AAAA,EACxB;;;ACzDO,MAAM,SAAN,MAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAmBlB,YAAY,SAAyB;AAlBrC,WAAQ,OAAe;AAmBrB,WAAK,QAAO,mCAAS,QAAO,KAAK;AACjC,WAAK,OAAO,mCAAS;AAAA,IACvB;AAAA,IACc,QACZ,MACA,SACmB;AAAA;AACnB,eAAO,MAAM,MAAM,KAAK,OAAO,MAAM,OAAO;AAAA,MAC9C;AAAA;AAAA,IACc,KACZ,MACA,MACA,SACiB;AAAA;AACjB,YAAI,CAAC,KAAK,KAAM,OAAM,IAAI,SAAS;AACnC,cAAM,WAAW,MAAM,MAAM,KAAK,OAAO,MAAM,iCAC1C,UAD0C;AAAA,UAE7C,SAAS;AAAA,YACP,mBAAmB,KAAK;AAAA,UAC1B;AAAA,UACA,MAAM,KAAK,UAAU,IAAI;AAAA,UACzB,QAAQ;AAAA,QACV,EAAC;AACD,YAAI,SAAS,WAAW,IAAK,OAAM,MAAM,SAAS,KAAK;AACvD,eAAO,MAAM,SAAS,KAAK;AAAA,MAC7B;AAAA;AAAA,IACc,QACZ,MACA,SACA,MACA,SACmB;AAAA;AACnB,eAAO,MAAM,MAAM,KAAK,OAAO,MAAM;AAAA,UACnC,QAAQ;AAAA,UACR;AAAA,UACA;AAAA,WACG,QACJ;AAAA,MACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAiBa,aACX,MACA,SAC+B;AAAA;AAC/B,cAAM,UAAU;AAChB,cAAM,SAAS;AAAA,UACb,GAAG,KAAK,SAAS;AAAA,UACjB,YAAY,KAAK,cAAc;AAAA,UAC/B,aAAa,KAAK,eAAe;AAAA,UACjC,UAAU,KAAK,WAAW,KAAK,WAAW,MAAO;AAAA,QACnD;AACA,cAAM,WAAW,GAAG,OAAO,IAAI,OAAO,QAAQ,MAAM,EACjD,OAAO,CAAC,CAAC,GAAG,KAAK,MAAM,UAAU,UAAa,UAAU,EAAE,EAC1D,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM,GAAG,GAAG,IAAI,mBAAmB,KAAe,CAAC,EAAE,EACrE,KAAK,GAAG,CAAC;AACZ,cAAM,WAAW,MAAM,KAAK,QAAQ,UAAU,OAAO;AAErD,YAAI,CAAC,SAAS,IAAI;AAChB,gBAAM,IAAI,aAAa;AAAA,QACzB;AACA,cAAM,OAAO,MAAM,SAAS,KAAK;AAEjC,YAAI,CAAC,MAAM;AACT,gBAAM,IAAI,cAAc;AAAA,QAC1B;AAEA,eAAO;AAAA,MACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAoBa,WACX,MACA,SAC6B;AAAA;AAC7B,cAAM,UAAU,KAAK,KAAK,IAAI,KAAK,EAAE,KAAK;AAC1C,cAAM,UAAU,SAAS;AACzB,cAAM,QAAO,6BAAM,YAAW,KAAK,WAAW,MAAO;AACrD,cAAM,SAAS;AAAA,UACb,YAAY,KAAK,cAAc;AAAA,UAC/B,aAAa,KAAK,eAAe;AAAA,UACjC,YAAY,KAAK,cAAc;AAAA,UAC/B,UAAU,QAAQ;AAAA,QACpB;AAEA,cAAM,WAAW,GAAG,OAAO,GAAG,OAAO,QAAQ,MAAM,EAChD,OAAO,CAAC,CAAC,GAAG,KAAK,MAAM,UAAU,UAAa,UAAU,EAAE,EAC1D,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM,GAAG,GAAG,IAAI,mBAAmB,KAAe,CAAC,EAAE,EACrE,KAAK,GAAG,CAAC;AAEZ,cAAM,WAAW,MAAM,KAAK,QAAQ,UAAU,OAAO;AACrD,YAAI,CAAC,SAAS,MAAM,SAAS,WAAW,KAAK;AAC3C,gBAAM,IAAI,cAAc;AAAA,QAC1B,WAAW,CAAC,SAAS,MAAM,SAAS,WAAW,KAAK;AAClD,gBAAM,IAAI,aAAa,SAAS,UAAU;AAAA,QAC5C;AAEA,cAAM,OAAO,MAAM,SAAS,KAAK;AAEjC,eAAO;AAAA,MACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAoBa,YAAY,MAA0C;AAAA;AACjE,YAAI;AACF,gBAAM,OAAO,MAAM,KAAK,WAAW,IAAI;AACvC,cAAI,WAAW,KAAM,QAAO;AAE5B,gBAAM,iBAAiB,6BAAM;AAC7B,gBAAM,iBAAiB,KAAK;AAC5B,cAAI,eAAgB,QAAO,CAAC,EAAE,MAAM,iBAAiB,CAAC;AAEtD,cAAI,CAAC,eAAgB,QAAO;AAE5B,iBAAO,iBAAiB,cAAc,EAAE;AAAA,QAC1C,SAAS,GAAG;AACV,kBAAQ,MAAM,CAAC;AACf,iBAAO;AAAA,QACT;AAAA,MACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAoBa,UAAU,MAA0C;AAAA;AAC/D,YAAI;AACF,gBAAM,OAAO,MAAM,KAAK,WAAW,IAAI;AACvC,gBAAM,eAAe,6BAAM;AAC3B,gBAAM,iBAAiB,KAAK;AAC5B,cAAI,eAAgB,QAAO,CAAC,EAAE,MAAM,iBAAiB,CAAC;AAEtD,cAAI,CAAC,aAAc,QAAO;AAE1B,iBAAO,iBAAiB,YAAY,EAAE;AAAA,QACxC,SAAS,GAAG;AACV,kBAAQ,MAAM,CAAC;AACf,iBAAO;AAAA,QACT;AAAA,MACF;AAAA;AAAA,IACa,mBAAsD;AAAA;AAzOrE;AA0OI,YAAI;AACF,gBAAM,YAAY,MAAM,KAAK,QAAQ,oBAAoB;AACzD,cAAI,CAAC,UAAU,GAAI,OAAM,IAAI,aAAa,UAAU,UAAU;AAC9D,gBAAM,WAAW,MAAM,UAAU,KAAK;AACtC,cAAI,CAAC,SAAS,UAAU,CAAC,SAAS,OAAQ,QAAO;AACjD,iBAAO;AAAA,YACL,QAAQ,SAAS;AAAA,YACjB,QAAQ,SAAS;AAAA,UACnB;AAAA,QACF,SAAS,GAAQ;AACf,gBAAM,IAAI,OAAM,4BAAG,YAAH,YAAc,eAAe;AAAA,QAC/C;AAAA,MACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkCF;","names":[]}